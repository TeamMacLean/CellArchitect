//#########################################################################################################################
// 	Script name: CellArchitect.script
// 	Version: 1.15
//
// 	The Silke Robatzek Group
//	The Sainsbury Laboratory, Norwich Research Park, Norwich, UK
//
//	Author: Dr Ji Zhou
//	Email: ji.zhou@jic.ac.uk, ji.zhou@earlham.ac.uk
//  Date: 18-December-2016
//
// 	System Requirements:
//           To allow the use of this script, Acapella framework (v2.0 or above) and Windows XP are required.
//
//	Changes: Changed the density calculation, update stomata detection, and cell selection criteria to include
//		     density detection at the cell level
//
//  User Manual:
//		This software solution is designed to recognise microtubule (MT) and measure MT pattern changes induced by
//		different chemicals. The algorithm is capable of detecting other microfilament structure such as actin as
//      well. Output fields (in a variety of CSV files) quantify features such as size, shape, fluorescent signal
//      intensity, and MT patterns (e.g. MT lengths). Users need to follow the following instructions to execute
//      the CellArchitect:
//
//		* 	Selecting "Image Directory" to choose the image location of Opera images.
//		* 	If the user wants to use Voronoi diagrams to present MT distribution, tick the "Produce Voronoi
//          Diagram" selection.
//		* 	If the user wants to generate a time-lapse movie of the flex file to present the morphological changes
//          of MT structure, tick "Produce an AVI video".
//		*	Users can change the value in "Stack No" input box to defined the number of z-stacks in a flex file that
//          need to be analysed.
//		*	Users can change the value in "Camera No" input box to defined the number of laser cameras used in imaging.
//		* 	If users want to preview analysed images within the Acapella framework, tick "Show Illustration".
//		* 	A user can change the frames per second input to produce avi movies with different key frames.
//
//		This software solution performs traditional image analysis functions such as image enhancement, object
//      segmentation, denoise, edge-based measurements, and skeletonisation.
//      When adding new functions to CellArchitect, please add them as external procedures or internal functions to
//      maintain software architecture.
//
//
// 	Copyright:   (C) The Sainsbury Laboratory, Norwich
//
//#########################################################################################################################

//###########################################################################################
//#	STEP ONE. Establish INPUT PARAMETERS 																			   		   #
//###########################################################################################

//// Set up the user input form....
input(StackNo, 0, "Stack No", "i", "The number of zstacks to be analysed. If set to 0 (ZERO), all zstacks are going to be evaluated.")
input(CameraNo, 2, "Camera No", "i", "How many camera(s) has been used in the experiment - TWO cameras are expected.")
input(ZplanesInStack, 25,"How many Z-planes captured in a zstack?","i","The number of Z-planes captured during the Opera imaging.")
input(ShowIllustrations, No, "Show Illustrations in Acapella?", "y", "YES - Output illustrations are depicted. No - Output illustrations are not displayed.")
input(GenerateVoronoi, YES, "Produce Voronoi Diagram", "y", "YES - Generate Voronoi Diagram. No - Do not generate an AVI movie.")
input(GenerateMovie, NO, "Produce an AVI video based on the flex file", "y", "YES - Generate an AVI video. No - Do not generate an AVI movie.")
input(MOV_Frame, 5,"-- Frames per second in the Movie","i","how many frames will be contained in a second?.")
//// End user input

///// Set up variables for later analysis
set(NumberOfChannels= CameraNo)
set(InvalidStacks = 0)
set(BadStack = false)
set(BadInput = false)

//Use singlewell to read flex files and turn them into internal data objects lists.
SingleWell(compact=yes) //the SourceData, SourceDataProp, WellIndex, and every slices will be output
set( imagefilename1 = SourceData.sourcefilename[0])
RobatzekProcs::ControlImageFieldsStackAC2(sourcedata, NumberOfChannels, ZplanesInStack, StackNo)
// Assign camera numbers
// Build an overall objects list
//Create an empty objectlist, same can be used for vector
create("objectlist")
rename(Overall_Objs_List = objectlist) 

// Find zoom used in the image acquisition  
set( ImagingZoom = substr( SourceData.ObjectiveRef[0], at("x", SourceData.ObjectiveRef[0], 1) - 2, 2))
Alias(_StackCounter, _FieldCounter)
Alias(StartField, StartStack)
Alias(EndField, EndStack)
///*** Finish creating variables and sorting zstacks ***///
///*********************************************************************************************///

//###########################################################################################
//#	STEP TWO. Prepare export files																											#
//###########################################################################################
//*** Prepare a Result folder for saving CSV results and processed images
	Set(current_Date = __date__)
	
	//*** Prepare output Result folder
	set( namelength = length( imagefilename1 ) )
	set( corename = substr( imagefilename1, 1, namelength - 5 ) )
	set( pathname = substr( imagefilename1, 1, at("/", imagefilename1, -1)))
	set( imagename = substr( imagefilename1, at("/", imagefilename1, -1) + 1))

	Set(CreateDir = pathname & current_Date & "_Results")
	Set(Output_File = current_Date & "_Overall_Results")
	Delete(FileInfo)
	FileInfo(CreateDir)		
	If(!fileinfo.exists) // Make a directory for CSV files 
		MkDir(CreateDir, 555) // Set the directory attributes - only required in case we run it on Linux machine
	End()

	Delete(FileInfo)
	FileInfo(CreateDir & "/" & Output_File & ".csv")	
	
	// Check whether or not the output file exists - if not create the output file, 
	// if so do not create the template for the output file again, otherwise the following function will overwrite 
	// the overall output file as it has the same file name
	//*** Prepare overall output CSV file - average MT size, intensity, cellular coverage
	If(!fileinfo.exists) 
		printfopen(CreateDir & "/" & Output_File & ".csv")
		Printf("Image_Name#")
		Printf("Well_Location#")
		Printf("Treatment#")
		Printf("Stack_No#")
		Printf("Experiment_Date#")
		Printf("Imaging_Start_Time#")
		Printf("Imaging_End_Time#")		
		Printf("Cell_Used#")
		Printf("MT_Intensity#")
		Printf("MT_Thickness#")		
		Printf("MT_Cov_Bin1#") // Bin1 - dot objects bin, skeleton shorter than 10 pixels
		Printf("MT_Cov_Bin2#") // Bin2 - small objects bin, skeleton between 11 and 35 pixels 
		Printf("MT_Cov_Bin3#") // Bin3 - middle_1 bin, skeleton between 36 and 60 pixels 
		Printf("MT_Cov_Bin4#") // Bin4 - middle_2 bin, skeleton between 61 and 85 pixels 
		Printf("MT_Cov_Bin5#") // Bin5 - middle_3 bin, skeleton between 86 and 110 pixels
		Printf("MT_Cov_Bin6#") // Bin6 - middle_3 bin, skeleton between 111 and 135 pixels
		Printf("MT_Cov_Bin7#") // Bin7 - long objects bin, skeleton longer than 136 pixels    
		Printf("MT_Cov_Per_Cell#") 
		Printf("Pixel_um#\n")
		printfopen() 
	End()	
	//** Finish preparing a CSV file for saving overall output results 
///*********************************************************************************************///


///*** STEP 2. Start To Read Image Data ***///
//// Start to load planes for input flex files
Foreach(StartStack .. EndStack, _StackCounter) 
// Loop - the number of iterations depends on how many stacks in a flex file.
	Printf("Reading Stack %s \n", _StackCounter)	
	// Assigns image names for the current field, Images_CH1 - first channel image, Image_CH2 - second channel image etc
	OperaTemplates::AssignStacks() 
	// MIP
	OperaTemplates::MaxProjections()
	// assign stacks will automatically divide images into multiple channels
	set( namelength = length( imagefilename1 ) )
	set( corename = substr( imagefilename1, 1, namelength - 5 ) )

	If(CameraNo == 2)
		Set(Microtubule_IMG = IM_Max_CH1)	
		Set(Microtubule_Value = IM_Max_CH1)
		Set(Cell_IMG = IM_Max_CH2)	
		Set(Cell_Value = IM_Max_CH2)
	Else()
		If(CameraNo == 3) // added for animal caner research 
			Set(Microtubule_IMG = IM_Max_CH3)	
			Set(Microtubule_Value = IM_Max_CH3)
			Set(Cell_IMG = IM_Max_CH2)	
			Set(Cell_Value = IM_Max_CH2)
			Set(Nuclei_IMG = IM_Max_CH1)	
			Set(Nuclei_Value = IM_Max_CH1)
		Else()
			Set(Microtubule_IMG = IM_Max_CH1)	
			Set(Microtubule_Value = IM_Max_CH1)
			Set(Cell_IMG = IM_Max_CH1)	
			Set(Cell_Value = IM_Max_CH1)
		End()
	End()

	// Fourier_based methods for frequency detection of MT pattern – added for animal research
	// Deprecated functions  
	// Fourier(IM_Max_CH1 | r1=ReImage, i1=ImImage)
	// Fourier(IM_Max_CH2 | r2=ReImage, i2=ImImage)
	// InvFourier(r1*r2+i1*i2, -r1*i2+i1*r2 , IM_Max_CH1.width)
	// set(correlator=InvImage/IM_Max_CH1.length-IM_Max_CH1.mean*IM_Max_CH2.mean)

	// Bayer Screening setting
	if(CameraNo == 2) 
//*** STEP 2.1: Detect Stomata in the Cell Channel ***// 
		RobatzekProcs::DetectStomata_PI_Stain(Cell_IMG, Cell_Value)
		//*** finish detecting stomata in plant cells ***//


//*** STEP 2.2: Detect Cell Boundary in the Cell Channel ***// 
		//** STEP 2.2.1: Detect Out of Focus Areas ***// 
		/// Start to detect the out of focus areas 
		RobatzekProcs::Detect_OutOfFocus(Cell_IMG)	
		CalcIntensity(Image=Cell_Value, CalcStdDev=yes, Total=no, objects=Cell_Out_Of_Focus_Area)
		CalcArea()
		ObjectFilter(area > 1)
		// Filtering based on intensity and intensity stddev, 1SD has been used
		ObjectFilter((area > 5250 && intensity < Cell_Value.mean * 0.725 && intensity_stddev > 0.5) || (area <= 5250 && area > 125 && ((intensity < Cell_Value.mean * 0.625 && intensity_stddev > 0.75) || (intensity < Cell_Value.mean * 0.675 && intensity_stddev > 1.25))) || (area <= 125 && area >= 12.5 && ((intensity < Cell_Value.mean * 0.525 && intensity_stddev > 0.95) || (intensity < Cell_Value.mean * 0.625 && intensity_stddev > 1.25))) || (area < 12.5 && intensity < Cell_Value.mean * 0.525 && intensity_stddev > 0.5))
		Set(Cell_Out_Of_Focus_Area = objects)
		Set(Out_Of_Focus_Mask = Cell_Out_Of_Focus_Area.body.mask.image)

	
		//** STEP 2.2.2: Detect Cell Boundaries ***// 
		//###########################################################################################
		//#	The following process is unique for Bayer Screening - according to the settings of image acquisition		   #
		//###########################################################################################
	
		///** A) Find ROI using Convolution ***///
		//Transforms the image into its gradient
		set(convolutionkernel=toimage(vec(1,4,16,4,1,  4,16,32,16,4,  16,32,128,32,16,  4,16,32,16,4,  1,4,16,4,1),5,5).image) // build up a convolution kernel
		set(convolutionkernelfactor=convolutionkernel.sum)
		convolution(image = Cell_IMG)
		Set(Convolution_IMG = image) 
		// Process images with a convolution filter, so that the sharp edge can be soften 
		// Convolution kernel used in this analysis will enable better detection of the cell wall 
	
		// Using bright mask of points, which are brighter than surrounding areas 
		Bright_Mask(Convolution_IMG, 6.5) 
		// Start to detect the cell wall 
		// using adaptive thresholding 
		Mask(Threshold=Cell_IMG.mean * 0.09, Image=result) 
		// Start to build up intial ROI objects list
		Mask2Stencil(Neighbourhood = 4)
		Stencil2Objects()
		RobatzekProcs::FillSmallHoles(25, objects = objects) // fill small holes within stomata aperture 
		CalcArea(body, AutoRecalc=yes)
		ObjectFilter(area > 2)
		CalcIntensity(Image=Cell_Value, Total=yes, CalcStdDev=yes)
		CalcAttr(AVG_Intensity, (intensity/area))
		Set(Intensity_Threshold = Cell_Value.mean)
		ObjectFilter(AVG_Intensity > Intensity_Threshold * 0.75 || area > Cell_Value.size * 0.05) 
		// The convolution filter did not work out and produced a very large mask 
		object_contrast_general(reference = Cell_Value, ContrastDef = "WithoutCyto")	
		ObjectFilter(contrast > 0.095 && (contrast > 0.225 || intensity_stddev > 0.525 || AVG_Intensity > Intensity_Threshold * 1.325))
		set(Cell_Convolution = Objects) 
		// Initial ROI objects have been detected 	

		//*** Prepare a Result folder for saving CSV results and processed images
		//*** Brighten cell boundary ***//	
		expand(12.5, 0.05, image=Cell_IMG)
		// Remove 25% of the dark pixels, which can remove many noisy signals
		set(Cell_Detection_Channel = Cell_IMG)
		////// Finish Pre-processing Cell Boundary Images 		
	
		/// B) Draw the cell boundary based on bright mask 
		///// The bright mask shall be treated as a main mask as it is generated from the original max projection
		Bright_Mask(Cell_Detection_Channel, 5) // Using bright mask will balance the image
		// 75% of the brightest pixels on the image
		Mask(Threshold=Cell_IMG.mean * 0.15, Image=result) 
		Mask2Stencil(Neighbourhood= 8) /// DO NOT USE MASK_BRIGHT as it generates too much noise
		Stencil2Objects()
		RobatzekProcs::FillSmallHoles(25, objects = objects) // fill small holes within stomata aperture 
		CalcArea(objects=objects)	
		ObjectFilter(area > 2) // get rid of small pixels
		CalcIntensity(Image=Cell_Value, Total=yes, CalcStdDev=yes)
		CalcAttr(AVG_Intensity, (intensity/area))
		Set(Intensity_Threshold = Cell_Value.mean)
		ObjectFilter(AVG_Intensity > Cell_Value.mean * 0.75 && intensity_stddev >= 0.5)
		// The convolution filter did not work out and produced a very large mask 
		object_contrast_general(reference = Cell_Value, ContrastDef = "WithoutCyto")	
		ObjectFilter(contrast > 0.225 || intensity_stddev > 0.75)
		ObjectFilter(area > 225 || contrast > 0.2 || (intensity_stddev > 1.1 && AVG_Intensity > Cell_Value.mean) || (contrast > 0.1 && AVG_Intensity > Cell_Value.mean * 1.1)) 
		Set(Cell_BM_Obj_initial = objects)
	
		// Adding brightest parts of the image as they might be lost in the bright_mask function
		ThresholdXX(TuneTH = 1.25, Image=Cell_IMG) 
		Mask(Threshold=Threshold * 2.5, Image=Cell_IMG)  
		Mask2Stencil() 
		Stencil2Objects()
		set(Cell_ROI_Brightest_Intensity=Objects) 
	
		/// C) Assemble the stomata objects on the initial BM objects 
		Or(Cell_BM_Obj_initial.body.mask.image, image = Cell_stomata_mask) // Add stomata
		Or(image, image = Cell_Convolution.body.mask.image) // Add convolution masks
		Or(image, image = Cell_ROI_Brightest_Intensity.body.mask.image) // Add brightest regions 	
		Set(Cell_Mask_INI = image)
		// Finish assembling the initial masks for further analysis 

		/// D) Draw the cell boundary based on bright mask 
		Mask2Stencil(Cell_Mask_INI, Neighbourhood= 8)
		Stencil2Objects()		
		RobatzekProcs::FillSmallHoles(25, objects = objects) // fill small holes within stomata aperture 
		CalcArea(objects=objects)	
		ObjectFilter(area >= 2)
		CalcIntensity(Image=Cell_Value, CalcStdDev=yes, Total=no)
		ObjectFilter(intensity > Cell_Value.mean * 0.7 && intensity_stddev > 0.5)
		object_contrast_general(objects, Cell_Value, "WithoutCyto")
		ObjectFilter(contrast > 0.095 || intensity >  Cell_Value.mean * 1.05 || intensity_stddev > 1.05) 
		// remove pixels with lower contrast
		ObjectFilter(area >= 150 || intensity > Cell_Value.mean * 1.15 || intensity_stddev > 1.25 || contrast > 0.0975) 
		// remove small pixels
		// Filtering based on intensity and intensity stddev, 1SD 	
	
		CalcWidthLength(Upto100=yes)
		ObjectFilter((full_length > 22.5 && (contrast > 0.09 || intensity_stddev > 1.25)) || (area <= 125 && area > 25 && (intensity_stddev > 1.75 || contrast > 0.1) && intensity > Cell_Value.mean * 0.75) || (area > 125 && ( intensity_stddev > 2.25 || contrast > 0.125) && intensity > Cell_Value.mean * 0.85) || (area <= 25 && (intensity_stddev > 1.5 || (contrast > 0.0975 && intensity_stddev > 0.0975)) && intensity > Cell_Value.mean * 0.65))
		// Filtering based on contrast and object size	
		ObjectFilter(area > 75 || contrast > 0.15 || (area <= 75 && contrast > 0.05 && intensity_stddev > 0.0975), objects = objects)	
		// Filtering based on a variety of attributes
		ObjectFilter(full_length > 15 || half_width > 3.25 || intensity >  Cell_Value.mean * 1.25 || (contrast > 0.075 && intensity_stddev > 0.0975))
		CalcAttr(Real_WL_Ratio, (area / full_length)/full_length) 
		RenameAttr(Global_Contrast = contrast)
		object_contrast_general(reference=Cell_Value, ContrastDef="WithCyto", InitialMask=Cell_BM_Obj_initial.body.mask)
		// Generate local contrast 
		ObjectFilter(contrast > 0.08 || full_length > 25 || intensity_stddev > 3.25 || intensity > Cell_Value.mean * 1.25 || (area < 125 && (intensity_stddev > 1.75 || (contrast > 0.05 && intensity_stddev > 0.0975))))
		Set(Cell_BM_Obj_Processed = objects)
		
		/// E) Divide detected objects into two groups
		ObjectFilter(area > 325, objects=Cell_BM_Obj_Processed)
		Set(Cell_BM_BIG_Obj_initial = objects)
		ObjectFilter(area <= 325, objects=Cell_BM_Obj_Processed)
		Set(Cell_BM_SMALL_Obj_initial = objects)
			
		// Remove noise signals in the small cell wall objects
		CalcIntensity(Image=Cell_Value, CalcStdDev=yes, total = no, Objects = Cell_BM_SMALL_Obj_initial) 	
		// use the original max projection to get the intensity
		object_contrast_general(reference = Cell_Value, ContrastDef = "WithoutCyto")	
		CalcWidthLength(Upto100=yes)
		ObjectFilter((contrast > 0.0325 || intensity_stddev > 2.25) && (full_length > 22.5 || (intensity_stddev > 1.25 &&  intensity >  Cell_Value.mean * 1.25) || (area <= 15 && contrast > 0.0275 && intensity_stddev > 0.0975 && intensity >  Cell_Value.mean * 0.875) || (area > 15 && area <= 125 && ((contrast > 0.075 && intensity_stddev > 0.75) || (contrast > 0.05 && intensity >  Cell_Value.mean * 0.925 && intensity_stddev > 1.125))) || (area > 125 && ((contrast > 0.1 && intensity_stddev > 1.25) || (contrast > 0.075 && intensity > Cell_Value.mean * 1.025 &&  intensity_stddev > 2.25)))))		
		ObjectFilter(contrast > 0.125 || intensity > Cell_Value.mean * 2.5 || intensity_stddev > 5.25 || (area > 125 && intensity_stddev > 2.25 && contrast > 0.1) || (area <= 125 && area > 15 && (intensity_stddev > 2.25 || (contrast > 0.06 && intensity_stddev > 0.85)) && intensity > Cell_Value.mean * 1.025) || (full_length > 15 && (contrast > 0.1 || intensity_stddev > 1.5)) || (intensity > Cell_Value.mean * 0.925 && intensity_stddev > 1.25 && contrast > 0.075) || (area <= 15 && contrast > 0.0325 && intensity_stddev > 0.0975 && intensity >  Cell_Value.mean * 0.875) ) 			
		Set(Cell_BM_SMALL_Obj_refined = objects)
	
		// Remove noise signals in the big cell wall objects
		CalcIntensity(Image=Cell_Value, CalcStdDev=yes, total = no, Objects = Cell_BM_BIG_Obj_initial) 	
		// use the original max projection to get the intensity
		object_contrast_general(reference = Cell_Value, ContrastDef = "WithoutCyto")	
		ObjectFilter(contrast > 0.0125 && (contrast > 0.15 || intensity > Cell_Value.mean * 2.5 || intensity_stddev > 9.25 || area > 2500 || (contrast > 0.075 && intensity_stddev > 1.5 && intensity > Cell_Value.mean))) 			
		Set(Cell_BM_BIG_Obj_refined = objects)
		
		/// F) Combine main cell wall with refined small cell walls 
		Or(Cell_BM_SMALL_Obj_refined.body.mask.image, image = Cell_BM_BIG_Obj_refined.body.mask.image)		
		Or(image, image = cell_stomata_mask)
		Mask2Stencil(image, Neighbourhood= 8)
		Stencil2Objects()
		RobatzekProcs::FillSmallHoles(25, objects = objects) // fill small holes within stomata aperture 
	
		Set(stencil = objects.body)
		CalcErosion(0, objects = objects, Stencil = stencil) // decreasing 1 pixel
		RenameAttr(body = stencil_eroded)
		// Filter based on areas and contrast
		CalcArea(objects=objects)
		CalcIntensity(Image=Cell_Value, CalcStdDev=yes, total = no)
		object_contrast_general(reference = Cell_Value, ContrastDef = "WithoutCyto")
		ObjectFilter(area > 5 && (area > 12.5 || (contrast > 0.05 && intensity_stddev > 1.05)))
		// use the original max projection to get the intensity
		
		CalcIntensity(border, Cell_Value, CalcStdDev=yes, objects=objects, total = no)
		CalcAttr(Intensity_Contrast, ((intensity + intensity_stddev) - (border_intensity + border_intensity_stddev)) / ((intensity + intensity_stddev) + (border_intensity + border_intensity_stddev))*100) 
		CalcWidthLength(Upto100 = yes) // Filtering small objects
		ObjectFilter(Intensity_Contrast > 2.5 || (area > 500 && contrast > 0.085 && intensity_stddev > 1.5) || contrast > 0.125 || (intensity_Contrast > 1.25 && intensity_stddev > 2.75) || intensity_stddev > 5.25 || (area < 250 && area > 125 && (contrast > 0.075 || intensity_stddev > 5.25)) || (area <= 125 && area >= 25 && contrast > 0.065 && intensity_stddev > 0.125) || (area < 25 && contrast > 0.055 && intensity_stddev > 0.0975) || (full_length > 50 && intensity_stddev > 1.5)) 
		// average intensity and peak intensity difference		
		CalcAttr(WidthLengthRatio, (half_width * 2 / full_length)) 
		ObjectFilter(full_length > 1)
		CalcAttr(Real_WL_Ratio, (area / full_length)/full_length) 
		ObjectFilter((contrast > 0.0725 || (contrast > 0.0275 && intensity_stddev > 1.125)) && ((full_length > 15 && half_width >= 2 && WidthLengthRatio > 0.125 && intensity_stddev > 1.25 && Intensity_Contrast > 0.25 && contrast > 0.15) || area > 1250 || contrast > 0.225 || ((Real_WL_Ratio <= 0.275 || WidthLengthRatio < 0.325) && intensity_stddev > 1.25 && Intensity_Contrast > 0.25 && contrast > 0.15) || (area < 125 && intensity_stddev > 0.75 && (contrast > 0.095 || Intensity_Contrast > 1.75 || intensity_stddev > 3.25 || (contrast > 0.05 && intensity_stddev > 0.975))) || full_length > 50))	
		// Exceptional cases 
		ObjectFilter(!( area > 500 && contrast < 0.1 &&  Intensity_Contrast < 1.25 && Real_WL_Ratio > 0.75))
		Set(Cell_BM_Obj = objects)	
	
		// Expand the detected cell border with 1 pixel
		Set(stencil = Cell_BM_Obj.body)
		CalcErosion(-1, objects = objects, Stencil = stencil) // increasing 1 pixel
		RenameAttr(body = stencil_eroded)	
		Mask2Stencil(objects.body.mask.image, Neighbourhood= 4)
		Stencil2Objects()
		RobatzekProcs::FillSmallHoles(25, objects = objects) // fill small holes within stomata aperture 
		CalcArea(objects=objects)
		object_contrast_general(reference = Cell_Value, ContrastDef = "WithoutCyto")	
		CalcIntensity(Image=Cell_Value, CalcStdDev=yes, total = no)
		CalcWidthLength(Upto100 = yes) 
		CalcAttr(WidthLengthRatio, (half_width * 2 / full_length)) 
		CalcAttr(Real_WL_Ratio, (area / full_length)/full_length) 
		ObjectFilter(contrast > 0.075 && ((area > 125 && full_length > 22.5 && half_width > 2 && WidthLengthRatio > 0.12 && intensity_stddev > 2.25 && contrast > 0.085) || area > 1500 || (contrast > 0.225 && intensity_stddev > 2.25) || (Real_WL_Ratio <= 0.225 && intensity_stddev > 1.5 && contrast > 0.1) || (area < 125 && (contrast > 0.15 || intensity_stddev > 2.25 || (contrast > 0.075 && intensity_stddev > 1.25))) || (full_length > 50 && contrast > 0.125)))	
		RenameAttr(Global_Contrast = contrast)
		object_contrast_general(reference=Cell_Value, ContrastDef="WithCyto", InitialMask=Cell_BM_Obj.body.mask)
		// Generate local contrast 
		ObjectFilter(contrast > 0.07 && (contrast > 0.1325 || (full_length > 50 && contrast > 0.1) || intensity_stddev > 4.25 || intensity > Cell_Value.mean * 1.525 || (contrast > 0.0925 && intensity_stddev > 1.5 && area > 25 && area < 125)))
		Set(Cell_BM_Obj_refined = objects)
		set(Cell_BM_IMG = Cell_BM_Obj_refined.body.mask.image)	
	
		ObjectFilter(contrast > 0.175 && (full_length >= 50 || Real_WL_Ratio <= 0.1), objects=Cell_BM_Obj_refined)
		Set(Cell_BM_Obj_refined_Skeleton = objects)
		set(Cell_BM_IMG_SKL = Cell_BM_Obj_refined_Skeleton.body.mask.image)	
		//// Finish building the bright pixel areas of the image, without small spots
		// Assemble out of focus area with the cell boundary signals 
		Or(Cell_BM_IMG, image = Out_Of_Focus_Mask)
		Set(Cell_Boundary_IMG_Final = image)
		//*** Finish detecting cell wall and out of focus areas based on balanced Bright Mask ***//			


//*** STEP 2.2.3: Detect Cell Boundary in the Cell Channel ***// 
		/// A) Combine cell wall with stomata 	
		Or(Cell_Boundary_IMG_Final, image = cell_stomata_mask)		
		Mask2Stencil(image, Neighbourhood=4)
		Stencil2Objects()
		Inverse(dynamic=yes, image=objects.body.mask.image) 
		// inverse image to transfer stomata pixels into dark pixels 
		set(Cells_IMG_Initial = image)	
		// Start to process cell image
		Mask2Stencil(Cells_IMG_Initial)
		Stencil2Objects()
		RobatzekProcs::FillSmallHoles(35, objects = objects) // fill small holes within stomata aperture 
		Set(stencil = objects.body)
		CalcErosion(3, objects = objects, Stencil = stencil) // decreasing 3 pixels
		// Break the small gaps on the cell wall
	
		/// B) Start to reassemble the cell objects
		Mask2Stencil(objects.stencil_eroded.mask.image, Neighbourhood=8) // connect attached pixels
		Stencil2Objects()
		FillObjects() // fill small holes within stomata aperture 
		Mask2Stencil(objects.body.mask.image, Neighbourhood=8) // connect attached pixels
		Stencil2Objects()
		CalcArea()
		ObjectFilter(area > 25) // remove small pixels
		// Recalculate stencil 
		Set(stencil = objects.body)
		CalcErosion(-30, objects = objects, stencil = stencil) // increasing 30 pixels
		RenameAttr(body = stencil_eroded)
		Set(stencil = objects.body)
		CalcErosion(3, objects = objects, stencil = stencil) // decreasing 3 pixels
		RenameAttr(body = stencil_eroded)
		CalcArea()
		ObjectFilter(area > 125) // 75 pixel^2 has been filled
		set(Cells_Output_INI = objects)
	
		/// C) Assemble stomata and out-of-focus areas
		Inverse(dynamic=yes, image=Cells_Output_INI.body.mask.image) 
		// Or(image, image = Cell_BM_Obj_refined_Skeleton.body.mask.image)
		Or(image, image = Cell_stomata_Obj.body.mask.image) // Add stomata
		Or(image, image = Out_Of_Focus_Mask) // Add out-of-focus areas 
		Inverse(dynamic=yes, image = image) 
		Mask2Stencil(image)
		Stencil2Objects()
		RobatzekProcs::FillSmallHoles(250, objects = objects) // fill small holes within stomata aperture 
	
		// Reassemble the object list
		Mask2Stencil(objects.body.mask.image)
		Stencil2Objects()
		FillObjects()
		CalcArea(AutoRecalc=yes)
		Set(Area_Threshold = objects.area.mean)
		Set(Cells_Output_Final_INI = objects)
	
		ObjectFilter(area < Cell_Value.size * 0.4325 && (area > Cell_Value.size * 0.0125 || area > 3250))
		// In case objective has been changed during the image acquisition 		
		// get rid of small segmentation 
		RobatzekProcs::CalcRoundnessCorrected(objects=objects)		
		CalcIntensity(Image=Microtubule_Value, CalcStdDev=yes, total = no)
		ObjectFilter(intensity > Microtubule_Value.mean * 0.6 && (intensity > Microtubule_Value.mean * 1.25 || intensity_stddev > 6.25))
		ObjectFilter((RoundnessCorrected > 0.475 && intensity > Microtubule_Value.mean * 0.725) || (area > Area_Threshold * 0.25 && intensity > Microtubule_Value.mean * 0.7 && RoundnessCorrected > 0.525) || (area > Area_Threshold * 0.25 && intensity_stddev > 6.75 && intensity > Microtubule_Value.mean * 0.625))
		// Find half_width
		CalcWidthLength(Upto100=no)
		CalcAttr(WL_Ratio, 2 * half_width / full_length)
		ObjectFilter(!(half_width < 25 && WL_Ratio < 0.325 && RoundnessCorrected < 0.625 && full_length < 170))
		CalcIntensity(Image=Cell_Value, CalcStdDev=yes, total = no)	
		set(Intensity_Threshold = objects.intensity.median)
		ObjectFilter(intensity > Cell_Value.mean * 0.525 && intensity > Intensity_Threshold * 0.7 && intensity_stddev > 1.5)
		ObjectFilter((intensity > Cell_Value.mean * 0.625 && area <= Area_Threshold) || (Intensity_stddev > 3.25 && intensity > Cell_Value.mean * 0.825) || (area > Area_Threshold && intensity > Cell_Value.mean * 0.625))	
		// RenameAttr(Region_Intensity = intensity)
		// Make sure that the recognised cells contain MT signals from the MT channel
		CalcAttr(True_Cell, 1)
		CalcMassCentre()
		CalcIntensity(MassCentre, Cell_Value, Total=no)
		CalcIntensity(border, Cell_Value, Total=no)
		CalcAttr(Border_Diff_1, MassCentre_intensity - border_intensity)
		CalcAttr(Border_Diff_2, intensity - border_intensity)
		ObjectFilter(Border_Diff_1 > -12.5 && Border_Diff_2 > -10 && Border_Diff_2 < 5 && (Border_Diff_1 > -5 || Border_Diff_2 > -5))
		set(Cells_Output_Final = objects)
		Set(Cells_Final_IMG = Cells_Output_Final.body.mask.image)
	
		Set(stencil = Cells_Output_Final.body)
		CalcErosion(1, objects = Cells_Output_Final, stencil = stencil) // increasing 1 pixel
		Inverse(dynamic=yes, image=objects.stencil_eroded.mask.image)
		Set(Cells_Final_IMG_Inversed = image)
		//*** Finish detecting and locating cells worth analysing 

	Else() // One camera for ER and Actin, three cameras experiments added for cancer research 
		If(CameraNo == 3)
			Bright_Mask(Nuclei_IMG, 5.25) // get the details from the image 
			Mask2Stencil(M_bright)
			Stencil2Objects(Neighbourhood=4)
			CalcArea()
			ObjectFilter(area > 25)
			CalcIntensity(Image=Nuclei_IMG, CalcStdDev=yes, total = no)
			ObjectFilter(intensity > Nuclei_IMG.mean)
			FillObjects()
			Set(Nuclei_Obj_INI = objects)		
			
			// Using convolution to detect
			set(convolutionkernel=toimage(vec(1,4,16,4,1,  4,16,32,16,4,  16,32,128,32,16,  4,16,32,16,4,  1,4,16,4,1),5,5).image) // build up a convolution kernel
			set(convolutionkernelfactor=convolutionkernel.sum)
			convolution(image = Nuclei_IMG)
			Set(Convolution_Nuclei_IMG = image) 
			// Process images with a convolution filter, so that the sharp edge can be soften 
			// Convolution kernel used in this analysis will enable better detection of the cell wall 
			// Using bright mask of points, which are brighter than surrounding areas 

			// using adaptive thresholding 
			Mask(Threshold= Convolution_Nuclei_IMG.mean, Image=Convolution_Nuclei_IMG) 
			// Start to build up intial ROI objects list
			Mask2Stencil(Neighbourhood = 4)
			Stencil2Objects()
			RobatzekProcs::FillSmallHoles(25, objects = objects) // fill small holes within stomata aperture 
			CalcArea(body, AutoRecalc=yes)
			ObjectFilter(area > 25)
			CalcIntensity(Image=Nuclei_IMG, Total=yes, CalcStdDev=yes)
			CalcAttr(AVG_Intensity, (intensity/area))
			Set(Intensity_Threshold = Nuclei_IMG.mean)
			ObjectFilter(AVG_Intensity > Intensity_Threshold * 0.5 || area > Nuclei_IMG.size * 0.05) 
			// The convolution filter did not work out and produced a very large mask 
			object_contrast_general(reference = Nuclei_IMG, ContrastDef = "WithoutCyto")	
			ObjectFilter(contrast > 0.25)
			FillObjects()
			set(Nuclei_Convolution = Objects) 

			Xor(Nuclei_Obj_INI.body.mask.image, image = Nuclei_Convolution.body.mask.image)
			Mask2Stencil(image)
			Stencil2Objects()
			CalcArea(body, AutoRecalc=yes)
			ObjectFilter(area > 5)
			CalcIntensity(Image=Nuclei_IMG, Total=no, CalcStdDev=yes)
			ObjectFilter(intensity > Nuclei_IMG.mean * 0.75) 
			object_contrast_general(reference = Nuclei_IMG, ContrastDef = "WithoutCyto")	
			ObjectFilter(contrast > 0.25 || intensity > Nuclei_IMG.mean * 2.25) 
			Set(Nuclei_Remaining_Obj = objects)
	
			And(Nuclei_Obj_INI.body.mask.image, image = Nuclei_Convolution.body.mask.image)
			Or(image, image = Nuclei_Remaining_Obj.body.mask.image)
			Mask2Stencil(image)
			Stencil2Objects()
			FillObjects()
			// RemoveBorderObjects(1)
			CalcArea(body, AutoRecalc=yes)
			ObjectFilter(area > objects.area.mean * 0.5)
			CalcMassCentre()
			CalcVoronoi(masscentre)        // "Classical" Voronoi graph creation based on Points
			CalcBorder(masscentre_voronoi)	
			Set(Nuclei_Final = objects)
			Set(Cells_Output_Final = Nuclei_Final) // using Nuclei as the cell segmentation objects 
			
			Set(stencil = Nuclei_Final.masscentre_voronoi_border)
			CalcErosion(-2, objects = Nuclei_Final, stencil = stencil) // increasing 2 pixels
			Set(Calc_Border_IMG = objects.stencil_eroded)
		End() // finish processing the segmentation 
	End()


///*** STEP 3:  Detect Microtubules in the MT Channel ***///
	//*** STEP 3.1: Detect MT based on Bright Mask ***// 
	//Discard the analysis if not enough cells have been found
	If((Cells_Output_Final.@count > 1 && Cells_Output_Final.area.max > Cell_Value.size * 0.025) || CameraNo == 1 || CameraNo == 3) 
		// at least TWO cell shall be found 
		Gamma(1.25, image = Microtubule_IMG)
		expand(2.5, 0.25, image = image)		
		set(Expanded_Microtubule_IMG = image) // increase the contrast for inner layer detection

		Bright_Mask(Expanded_Microtubule_IMG, 1.25) // get the details from the image 
		Mask2Stencil(M_bright)
		Stencil2Objects(Neighbourhood=8)
		CalcArea()
		ObjectFilter(area > 3)
		CalcIntensity(Image=Microtubule_Value, CalcStdDev=yes, total = no)
		ObjectFilter(intensity > Microtubule_Value.mean * 0.5)
		Set(MT_BM_Obj_INI = objects)		

		If(CameraNo == 2)
			And(Cells_Final_IMG, image = MT_BM_Obj_INI.body.mask.image)
			Set(MT_IMG_BM_INI = image) // Segmented MT image
		Else()
			Set(MT_IMG_BM_INI = MT_BM_Obj_INI.body.mask.image) // Segmented MT image
		End()

		/// A) Start to refine MT objects based on initial detection 
		Mask2Stencil(MT_IMG_BM_INI)
		Stencil2Objects()
		object_contrast_general(reference = Microtubule_Value, ContrastDef = "WithoutCyto")
		// use the original max projection to get the intensity
		CalcIntensity(Image=Microtubule_Value, CalcStdDev=yes, total = no)
		ObjectFilter(intensity > Microtubule_Value.mean * 0.5 && (contrast > 0.1 || intensity_stddev > 2.25))
		//CalcWidthLength(Upto100=yes)
		Set(MT_BM_Obj_Ref = objects)	
		Set(MT_IMG_BM_REF = objects.body.mask.image) // Refind MT Image based on BM approach

		/// B) Find the brightest areas on the image 
		ThresholdXX(1.5, Image=Expanded_Microtubule_IMG)
		Mask(threshold = threshold * 5.25, image = Expanded_Microtubule_IMG)
		Mask2Stencil()
		Stencil2Objects()
		If(CameraNo == 2)
			And(Cells_Final_IMG, image = objects.body.mask.image)
		Else()
			set(image = objects.body.mask.image)
		End()
		Mask2Stencil(image)
		Stencil2Objects()
		CalcArea()
		RobatzekProcs::CalcRoundnessCorrected(objects=objects)	
		Set(MT_Brightest_Regions = objects)

		/// C) Detect ROI 
		ThresholdXX(3.25, Image=Expanded_Microtubule_IMG)
		Mask(threshold = threshold, image = Expanded_Microtubule_IMG)
		Mask2Stencil()
		Stencil2Objects()
		Set(MT_BG_Obj = objects) // Segmented MT image
		If(CameraNo == 2)
			And(Cells_Final_IMG, image = MT_BG_Obj.body.mask.image)
		Else()
			set(image = MT_BG_Obj.body.mask.image)
		End()
		Set(MT_IMG_INI_BG = image) // Segmented MT image

		/// D) Analyse the same regions from two approaches  
		And(MT_IMG_INI_BG, image = MT_IMG_BM_REF)
		Set(MT_AND_IMG_INI = image)
		Mask2Stencil(MT_AND_IMG_INI, Neighbourhood=8)
		Stencil2Objects(Neighbourhood=8)
		CalcArea()
		object_contrast_general(reference = Microtubule_Value, ContrastDef = "WithoutCyto")
		// use the original max projection to get the intensity
		CalcIntensity(Image=Microtubule_Value, CalcStdDev=yes, total = no)
		ObjectFilter(area > 5 || intensity > Microtubule_Value.mean * 0.15 ) // get rid of dark pixels 
		ObjectFilter(intensity > Microtubule_Value.mean * 0.2 && (contrast > 0.125 || intensity_stddev > 2.75 || area > 12.5 || area == 1))
		Set(MT_Obj_INI = objects)

		/// E) Refine detection 
		Or(MT_Obj_INI.body.mask.image, image = MT_Brightest_Regions.body.mask.image)
		Mask2Stencil(image, Neighbourhood = 4)
		Stencil2Objects(Neighbourhood = 4)
		RobatzekProcs::FillSmallHoles(2.5, objects = objects) // fill small holes within stomata aperture 
		CalcArea()
		object_contrast_general(reference = Microtubule_Value, ContrastDef = "WithoutCyto")
		CalcIntensity(Image=Microtubule_Value, CalcStdDev=yes, total = no)
		ObjectFilter(area > 1 && (area > 5 || intensity > Microtubule_Value.mean || contrast > 0.15 || intensity_stddev > 2.25))
		// remove misdetected small pixels
		ObjectFilter(intensity > Microtubule_Value.mean * 0.5 && (contrast > 0.125 || intensity_stddev > 3.25))	
		CalcWidthLength(Upto100=yes)
		CalcAttr(Calc_width, half_width * 2)
		If(CameraNo == 2)
			CalcStat("mean", Stencil = objects.body, Image = Cells_Final_IMG_Inversed, AttrName="Overlap_Membrane", objects=objects)
			ObjectFilter(Overlap_Membrane < 0.125)
		Else()
			ObjectFilter(intensity > Microtubule_Value.mean * 0.525 && (contrast > 0.2 || intensity_stddev > 3.75))	
		End()
		Set(MT_Obj_Final = objects)

		/// F) Detect skeleton from the objects 
		CalcSkeletonByIntensity(SkeletonType="cornerconnected", Image=Microtubule_Value, IntensityEvalParam=-oo, Objects=MT_Obj_Final)
		set(stencil = objects.skeleton)
		Stencil2Objects(Neighbourhood = 4)
		CalcArea(AutoRecalc=yes)	
		CalcArea(border, AutoRecalc=yes)
		CalcIntensity(Image=Microtubule_Value, CalcStdDev=yes, Total=no) 
		// the skeleton should be brighter, otherwises discard the objects
		RenameAttr(Calc_Length = border_area) 
		//As the skeleton only has 1 pixel width, therefore, the perimeter equals to the full length  
		Set(Skeleton_detection_REF = objects)
		// Dots, small MT, medium MT, long MT

	//*** Step 3.2: Start to segment MT objects	
		Set(Obj_Counter = 0)
		// Contain MT objects
		Set(MT_Objects_Segment_Obj = Overall_Objs_List)
		Set(MT_Objects_Whole_Obj = Overall_Objs_List)
		// Contain MT skeleton objects
		Set(MT_Skeleton_Segment_Obj = Overall_Objs_List)
		Set(MT_Skeleton_Whole_Obj = Overall_Objs_List)

		// Save MT statistics in a table 
		create("table")
		// Add the row into the table
		// AppendToTable(table, NewRow)
		Set(MT_Statistics = table) // create an empty table to contain MT statistics


		// Start to go through every cell 
		Foreach(0..(Cells_Output_Final.@count - 1), Obj_Counter)
			// And(Cells_Output_Final[Obj_Counter].body.image, image = MT_Obj_Final.body.mask.image)
			CalcStat("mean", Stencil = MT_Obj_Final.body, Image = Cells_Output_Final[Obj_Counter].body.image, AttrName="Total_Overlap", objects=MT_Obj_Final)
			ObjectFilter(Total_Overlap>0, objects = objects)	
			//** Total overlapped spots
			CalcArea(AutoRecalc=yes)	
			CalcIntensity(Image=Microtubule_Value, CalcStdDev= yes, Total= yes) 
			CalcAttr(WL_Ratio, half_width * 2 / full_length)
			DeleteAttr(Calc_width)
			DeleteAttr(outerzone) // remove zone to avoid overlapping whilst adding objects
			DeleteAttr(zone)
			// Recalculate intensity based on original images
			Set(MT_Objects_Part_TMP = objects)
			Set(MT_Coverage_Cell = MT_Objects_Part_TMP.area.sum / Cells_Output_Final.area[Obj_Counter])

			// Judge whether or not a cell contains enough MT objects
			If(MT_Coverage_Cell < 0.1 || ((MT_Objects_Part_TMP.full_length.median < 3.75 && MT_Objects_Part_TMP.WL_Ratio.median > 0.625 && ((MT_Objects_Part_TMP.full_length.mean < 6.5 && MT_Coverage_Cell < 0.1325) || (MT_Objects_Part_TMP.full_length.mean < 4.25 && MT_Coverage_Cell < 0.15))) || (MT_Objects_Part_TMP.full_length.median < 4.05 && MT_Objects_Part_TMP.full_length.mean < 4.5 && MT_Objects_Part_TMP.WL_Ratio.median > 0.6 && MT_Coverage_Cell < 0.215) || (MT_Coverage_Cell < 0.175 && MT_Objects_Part_TMP.full_length.median < 4.25 && MT_Objects_Part_TMP.full_length.mean < 5.75  && MT_Objects_Part_TMP.WL_Ratio.median > 0.575)))
				Set(Cells_Output_Final.True_Cell[Obj_Counter] = 0)
			End()

			// Get rid of very long cells which do not contain enough MTs	
			If(Cells_Output_Final.full_length[Obj_Counter] > 325 && MT_Coverage_Cell < 0.25 && MT_Objects_Part_TMP.full_length.median < 3.75 && MT_Objects_Part_TMP.full_length.mean < 4.75 && MT_Objects_Part_TMP.WL_Ratio.mean > 0.625)
				Set(Cells_Output_Final.True_Cell[Obj_Counter] = 0)
			End()

			If(Cells_Output_Final.True_Cell[Obj_Counter] == 1)
				// Calculate MT Density 
				Set(stencil = MT_Objects_Part_TMP.body)
				CalcErosion(-2, objects = objects, Stencil = stencil) 
				// increasing 2 pixels - N +delta N - partical in a 2D box 
				RenameAttr(body = stencil_eroded)	
				Mask2Stencil(objects.body.mask.image, Neighbourhood= 4)
				Stencil2Objects()
				CalcArea(AutoRecalc=yes)	
				Set(MT_Density = objects.area.sum / Cells_Output_Final.area[Obj_Counter])
				// Finish calculating the MT Density in a cell 
	
				// Collect MTs from every cell and save in an overall MT objects list 	
				AddObjects(MT_Objects_Part_TMP, CheckOverlap=no, DeleteGeometry=no, KeepAutoRecalc=no, objects=MT_Objects_Whole_Obj)
				Set(MT_Objects_Whole_Obj = objects)
	
				//** Step 3.2.1: Look into patterns within a cell
				// Detect skeleton 
				CalcSkeletonByIntensity(SkeletonType="cornerconnected", Image=Microtubule_Value, IntensityEvalParam=-oo, Objects=MT_Objects_Part_TMP)
				set(stencil = objects.skeleton)
				Stencil2Objects(Neighbourhood=8)
				CalcArea(AutoRecalc=yes)	
				CalcArea(border, AutoRecalc=yes)
				// CalcIntensity(Image=Microtubule_Value, CalcStdDev= yes, Total= no) 
				// use expanded image to increase the difference between inner pore and its surrounding layers
				RenameAttr(Calc_Length = border_area) 
				CalcAttr(Cell_ID, (Obj_Counter + 1))
				Set(Total_Coverage = objects.Calc_Length.sum) 
				// Calculate how many pixels that cover the area of the cell 
				CalcAttr(MT_Obj_Coverage, Calc_Length / Total_Coverage)
				Set(MT_Skeleton_Part_TMP = objects)	
	
				// Collect MTs from every cell and save in an overall MT objects list 	
				AddObjects(MT_Skeleton_Part_TMP, CheckOverlap=no, DeleteGeometry=no, KeepAutoRecalc=no, objects=MT_Skeleton_Whole_Obj)
				Set(MT_Skeleton_Whole_Obj = objects)
	
			//** Step 3.2.2:  Start to categorise detected MT length into ten groups
				// Bin1: 1-10 pixels; Bin2: 11-35 pixels; Bin3: 36-60 pixels; Bin4: 61-85 pixels; Bin5: 86-110 pixels; Bin6: 111-135 pixels, Bin7: >136 pixels 
				ObjectFilter(Calc_Length >= 136, objects = MT_Skeleton_Part_TMP)
				Set(Skeleton_Cell_TMP_Bin7 = objects)
				ObjectFilter(Calc_Length >= 111 && Calc_Length < 135, objects = MT_Skeleton_Part_TMP)
				Set(Skeleton_Cell_TMP_Bin6 = objects)
				ObjectFilter(Calc_Length >= 86 && Calc_Length < 110, objects = MT_Skeleton_Part_TMP)
				Set(Skeleton_Cell_TMP_Bin5 = objects)
				ObjectFilter(Calc_Length >= 61 && Calc_Length < 85, objects = MT_Skeleton_Part_TMP)
				Set(Skeleton_Cell_TMP_Bin4 = objects)
				ObjectFilter(Calc_Length >= 36 && Calc_Length < 60, objects = MT_Skeleton_Part_TMP)
				Set(Skeleton_Cell_TMP_Bin3 = objects)
				ObjectFilter(Calc_Length >= 11 && Calc_Length < 35, objects = MT_Skeleton_Part_TMP)
				Set(Skeleton_Cell_TMP_Bin2 = objects)
				ObjectFilter(Calc_Length <= 10, objects = MT_Skeleton_Part_TMP)
				Set(Skeleton_Cell_TMP_Bin1 = objects)
				// Finish categorising the MT skeleton objects 
	
				// Insert statistics into the MT_Statistics_Table
				set(NewRow=cnt(Cell_ID= (Obj_Counter + 1), Len_Bin1_Cov = Skeleton_Cell_TMP_Bin1.Calc_Length.sum / Total_Coverage, Len_Bin2_Cov = Skeleton_Cell_TMP_Bin2.Calc_Length.sum / Total_Coverage, Len_Bin3_Cov = Skeleton_Cell_TMP_Bin3.Calc_Length.sum / Total_Coverage, Len_Bin4_Cov = Skeleton_Cell_TMP_Bin4.Calc_Length.sum / Total_Coverage, Len_Bin5_Cov = Skeleton_Cell_TMP_Bin5.Calc_Length.sum / Total_Coverage, Len_Bin6_Cov = Skeleton_Cell_TMP_Bin6.Calc_Length.sum / Total_Coverage, Total_MT_Length = Total_Coverage, Len_Bin7_Cov = Skeleton_Cell_TMP_Bin7.Calc_Length.sum / Total_Coverage, Total_MT_Area = MT_Objects_Part_TMP.area.sum, AVG_MT_Obj_Intensity = MT_Objects_Part_TMP.Intensity.sum / MT_Objects_Part_TMP.area.sum, AVG_MT_Thickness = MT_Objects_Part_TMP.area.sum / MT_Skeleton_Part_TMP.Calc_Length.sum, MT_Coverage_Per_Cell = MT_Density)) 
				// skeleton has 1 pixel as the width, average object thickness  
				// Add the row into the table
				AppendToTable(MT_Statistics, NewRow)
				Set(MT_Statistics = table)
	
			//** Step 3.2.3:  Start to segment MT based on every cell - presentation only
				Mask2Stencil(MT_Skeleton_Part_TMP.body.mask.image, "One large object")
				Stencil2Objects()
				CalcArea()
				CalcWidthLength(Upto100=yes)
				CalcIntensity(Image=Microtubule_Value, CalcStdDev=yes, Total=no) 
				CalcAttr(Cell_ID, (Obj_Counter + 1))
				DeleteAttr(outerzone) // avoid Interval Vector structure issue: IV766
				DeleteAttr(zone)
				Set(MT_Skeleton_TMP_Whole = objects) // MTs in one cell are treated as one object
				AddObjects(MT_Skeleton_TMP_Whole, CheckOverlap=no, DeleteGeometry=no, KeepAutoRecalc=no, objects=MT_Skeleton_Segment_Obj)
				Set(MT_Skeleton_Segment_Obj = objects)
				// MT Skeleton Assembled 
	
				Mask2Stencil(MT_Objects_Part_TMP.body.mask.image, "One large object")
				Stencil2Objects()
				CalcArea()
				CalcWidthLength(Upto100=yes)
				CalcIntensity(Image=Microtubule_Value, CalcStdDev=yes, Total=no) 
				CalcAttr(Cell_ID, (Obj_Counter + 1))
				DeleteAttr(outerzone) // avoid Interval Vector structure issue: IV766
				DeleteAttr(zone)
				Set(MT_Objects_TMP_Whole = objects) // MTs in one cell are treated as one object
				AddObjects(MT_Objects_TMP_Whole, CheckOverlap=no, DeleteGeometry=no, KeepAutoRecalc=no, objects=MT_Objects_Segment_Obj)
				Set(MT_Objects_Segment_Obj = objects)
				// MT Objects Assembled
			End()

			Gamma(1.25, image=Microtubule_Value)
			// Dot objects
			ObjectFilter(Calc_Length <= 10, objects=MT_Skeleton_Whole_Obj)
			If(objects.@count > 0)
				CarryObjects(objects.body, image.max)
				CarryObjects(objects.body, "Green")
			End()
			// Small Objects
			ObjectFilter(Calc_Length >= 11 && Calc_Length <= 25, objects=MT_Skeleton_Whole_Obj)
			If(objects.@count > 0)
				CarryObjects(objects.body, image.max)
				CarryObjects(objects.body, "Yellow")
			End()
			// Middle Objects
			ObjectFilter(Calc_Length > 25 && Calc_Length <= 135, objects=MT_Skeleton_Whole_Obj)
			If(objects.@count > 0)			
				CarryObjects(objects.body, image.max)
				CarryObjects(objects.body, "Orange")
			End()
			// Long Objects
			ObjectFilter(Calc_Length > 135, objects=MT_Skeleton_Whole_Obj)
			If(objects.@count > 0)
				CarryObjects(objects.body, image.max)
				CarryObjects(objects.body, "Red")
			End()
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_TMP_MT_HeatMap.png", image=Image, imageformat="png")	

			// Clear up the memory to contain new objects lists
			Delete(MT_Skeleton_Part_TMP)
			Delete(MT_Skeleton_TMP_Whole) 
			Delete(MT_Objects_Part_TMP) 
			Delete(MT_Objects_TMP_Whole)
			Delete(MT_Coverage_Cell) 
		End()


//###########################################################################################
//#	STEP FOUR: Fill the output file																										   #
//###########################################################################################
		If(MT_Objects_Segment_Obj.@count > 1) // at least one cell contain valid MT objects
			// Refine the final output for recognised cells 
			ObjectFilter(True_Cell == 1, objects = Cells_Output_Final)
			Set(Cells_Output_Final_refined = objects)

		//*** Step 3.3: Calculate gap/angles using Voronoi diagram 
			If(GenerateVoronoi)
				Set(stencil = MT_Obj_INI.body)
				CalcErosion(-1, objects = MT_Obj_INI, Stencil = stencil) // increasing 1 pixel
				RenameAttr(body = stencil_eroded)
				Inverse(dynamic=yes, image=objects.body.mask.image)
				Set(MT_GAP_IMG_INI = image)
				And(Cells_Output_Final.body.mask.image, image = MT_GAP_IMG_INI)
				Mask2Stencil(image, Neighbourhood=4)
				Stencil2Objects(Neighbourhood=4)
				CalcArea()
				ObjectFilter(area > 2)
				CalcMassCentre()
				Set(MT_Voronoi_Diagram_INI = objects)
				
				CalcVoronoi("MassCentre", FasterAlgorithm=no, objects=MT_Voronoi_Diagram_INI)
				CalcVoronoi("MassCentre_Voronoi", FasterAlgorithm=yes, objects=objects)
				
				CalcStat("mean", Stencil = objects.MassCentre_Voronoi_Voronoi, Image = Cells_Output_Final.body.mask.image, AttrName="Within_Cell_Region", objects=objects)
				ObjectFilter(Within_Cell_Region == 1, objects = objects)	
				//** Total overlapped spots
				CalcArea(MassCentre_Voronoi_Voronoi, AutoRecalc=yes)
				// Stencil2Objects(objects.MassCentre_Voronoi_Voronoi)

				// Produce Voronoi diagram
				Inverse(dynamic=yes, image=Cells_Output_Final_refined.body.mask.image)
				Mask2Stencil(image)
				Stencil2Objects()
				CalcIntensity(Image=Cell_Value, CalcStdDev=yes)
				Set(CellWall_with_OutOfFocus = objects)
		
				// Assemble objects
				AddObjects(MT_Voronoi_Diagram_INI, CheckOverlap=no)
				set(stencil = objects.body)
				CalcErosion(-5, objects = objects, Stencil = stencil) // increasing 3 pixels 
				RenameAttr(body = stencil_eroded)
				CalcBorder(body, AutoRecalc=yes)
				CalcStat("mean", Stencil = objects.body, Image = CellWall_with_OutOfFocus.body.mask.image, AttrName="Total_Overlap", objects=objects)
				ObjectFilter(Total_Overlap == 0, objects = objects)	
				CalcStat("mean", Stencil = objects.body, Image = Cells_Output_Final_refined.body.mask.image, AttrName="Cell_Overlap", objects=objects)
				ObjectFilter(Cell_Overlap == 1, objects = objects)					
				CalcArea()
				CalcArea(border, AutoRecalc=yes) // Calculate the perimeter 
				CalcWidthLength(Upto100 = yes)
				Set(MT_Voronoi_Diagram_REF = objects)
				//** Finish detecting Voronoi 

				// Start to go through every cell 
				Set(Cell_Counter = 0)
				Foreach(0..(Cells_Output_Final_refined.@count - 1), Cell_Counter)
					// And(Cells_Output_Final[Obj_Counter].body.image, image = MT_Obj_Final.body.mask.image)
					CalcStat("mean", Stencil = MT_Voronoi_Diagram_REF.body, Image = Cells_Output_Final_refined[Cell_Counter].body.image, AttrName="Cell_Overlap", objects=MT_Voronoi_Diagram_REF)
					ObjectFilter(Cell_Overlap>0, objects = objects)	
					calcattr(Calc_Distance, (border_area/(2*half_width) + full_length)/2) 
					// Average distance from the centre of the polygon
					//** Total overlapped spots
					DeleteAttr(Calc_width)
					DeleteAttr(outerzone) // remove zone to avoid overlapping whilst adding objects
					DeleteAttr(zone)
					// Recalculate intensity based on original images
					Set(Voronoi_Objects_Part_TMP = objects)
				End()
			End()


		//*** Step 4.1: prepare images	
			// Preview images
			If(ShowIllustrations)	
				If(CameraNo == 2)
					imageview(Cells_Output_Final.body, "Cells_Sampled", image=IM_Max_CH2, middlecolor=rgb(0x00,0xff,0x00))	
					imageview(MT_Obj_Final.body, "Detected_MT", image=IM_Max_CH1, middlecolor=rgb(0x00,0xff,0x00))	
				Else()
					imageview(MT_Obj_Final.body, "Detected_MT", image=IM_Max_CH1, middlecolor=rgb(0x00,0xff,0x00))	
				End()
			End()
		
			Gamma(1.25, image=Cell_Value)
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_1_Cell_IMG.png", image=Image, imageformat="png")
	
			Gamma(1.25, image=Cell_Value)
			CarryObjects(Cells_Output_Final_refined.body, image.max)
			CarryObjects(Cells_Output_Final_refined.body, "rainbow")
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_2_Sampled_Cells.png", image=Image, imageformat="png")
	
			Gamma(1.25, image=Microtubule_Value)
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_3_MT_IMG.png", image=Image, imageformat="png")
		
			Gamma(1.25, image=Microtubule_Value)
			CarryObjects(MT_Objects_Whole_Obj.body, image.max)
			CarryObjects(MT_Objects_Whole_Obj.body, "rainbow")
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_4_Detected_MTs.png", image=Image, imageformat="png")
		
			Gamma(1.25, image=Microtubule_Value)
			CarryObjects(MT_Skeleton_Whole_Obj.body, image.max)
			CarryObjects(MT_Skeleton_Whole_Obj.body, "rainbow")
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_5_MT_Skeletons.png", image=Image, imageformat="png")
			
			Gamma(1.25, image=Microtubule_Value)
			CarryObjects(MT_Skeleton_Segment_Obj.body, image.max)
			CarryObjects(MT_Skeleton_Segment_Obj.body, "rainbow")
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_6_Segmented_MTs.png", image=Image, imageformat="png")
	
			If(GenerateVoronoi)
				Gamma(1.25, image=Microtubule_Value)
				CarryObjects(MT_Voronoi_Diagram_REF.body, image.max)
				CarryObjects(MT_Voronoi_Diagram_REF.body, "rainbow")
				WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_7_Voronoi.png", image=Image, imageformat="png")
			End()
			
			Gamma(1.25, image=Microtubule_Value)
			ObjectFilter(Calc_Length <= 10, objects=MT_Skeleton_Whole_Obj)
			CarryObjects(objects.body, image.max)
			CarryObjects(objects.body, "Green")
			ObjectFilter(Calc_Length >10 && Calc_Length <= 25, objects=MT_Skeleton_Whole_Obj)
			CarryObjects(objects.body, image.max)
			CarryObjects(objects.body, "Yellow")
			ObjectFilter(Calc_Length > 25 && Calc_Length <= 135, objects=MT_Skeleton_Whole_Obj)
			CarryObjects(objects.body, image.max)
			CarryObjects(objects.body, "Orange")
			ObjectFilter(Calc_Length > 135, objects=MT_Skeleton_Whole_Obj)
			CarryObjects(objects.body, image.max)
			CarryObjects(objects.body, "Red")
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_8_MT_HeatMap.png", image=Image, imageformat="png")	
		
			// Record experiment time/date 
			Set(Experiment_Date = substr( Images_CH1.DateTime[0], 0, at("T", Images_CH1.DateTime[0], -1))) 
			Set(Imaging_Start_Time = substr( Images_CH1.DateTime[0], at("T", Images_CH1.DateTime[0], -1) + 1))
			Set(Imaging_End_Time = substr( Images_CH1.DateTime[Images_CH1.DateTime.size-1], at("T", Images_CH1.DateTime[Images_CH1.DateTime.size-1], -1) + 1))		

			//*** Step 4.2: prepare csv file	
			printfopen(CreateDir & "/" & Output_File & ".csv", yes)
			printf(imagename & "#")
			Printf("R" & Images_CH1.Row[0] & " C"& Images_CH1.Column[0] & "#")
			Printf(Images_CH1.AreaName[0] & "#")
			Printf( _StackCounter & "#")
			Printf( Experiment_Date & "#")
			Printf( Imaging_Start_Time & "#")
			Printf( Imaging_End_Time & "#")
			Printf(Cells_Output_Final_refined.@count & "#")
			Printf(MT_Statistics.AVG_MT_Obj_Intensity.mean & "#")
			Printf(MT_Statistics.AVG_MT_Thickness.mean & "#")
			Printf(MT_Statistics.Len_Bin1_Cov.mean & "#")
			Printf(MT_Statistics.Len_Bin2_Cov.mean & "#")
			Printf(MT_Statistics.Len_Bin3_Cov.mean & "#")
			Printf(MT_Statistics.Len_Bin4_Cov.mean & "#")
			Printf(MT_Statistics.Len_Bin5_Cov.mean & "#")
			Printf(MT_Statistics.Len_Bin6_Cov.mean & "#")
			Printf(MT_Statistics.Len_Bin7_Cov.mean & "#")
			Printf(MT_Statistics.MT_Coverage_Per_Cell.mean & "#")
			Printf(Images_CH1.ImageResolutionX@um.mean & "#\n")
			printfopen() 

		Else()
			// Cannot find enough suitable cell(s)
			Printf("Cannot find enough valid cells - image discard! \n")	
	
			Gamma(1.25, image=Cell_Value)
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_1_Cell_IMG.png", image=Image, imageformat="png")
			Gamma(1.25, image=Microtubule_Value)
			WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_2_MT_IMG.png", image=Image, imageformat="png")

			Set(Experiment_Date = substr( Images_CH1.DateTime[0], 0, at("T", Images_CH1.DateTime[0], -1))) 
			Set(Imaging_Start_Time = substr( Images_CH1.DateTime[0], at("T", Images_CH1.DateTime[0], -1) + 1))
			Set(Imaging_End_Time = substr( Images_CH1.DateTime[Images_CH1.DateTime.size-1], at("T", Images_CH1.DateTime[Images_CH1.DateTime.size-1], -1) + 1))		

			printfopen(CreateDir & "/" & Output_File & ".csv", yes)
			printf(imagename & "#")
			Printf("R" & Images_CH1.Row[0] & " C"& Images_CH1.Column[0] & "#")
			Printf(Images_CH1.AreaName[0] & "#")
			Printf( _StackCounter & "#")
			Printf( Experiment_Date & "#")
			Printf( Imaging_Start_Time & "#")
			Printf( Imaging_End_Time & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(NAN & "#")
			Printf(Images_CH1.ImageResolutionX@um.mean & "#\n")
			printfopen() 
			// End of output
		End()

		// Produce a movie for the generated images  
		If(GenerateMovie)
			If(CameraNo == 2)
				// Find the location and produce the movie
				set( filepath = substr( corename, 1, at("/", corename, -1)))
				WriteVideo(CreateDir & "/" & imagename & "_stack_" & _StackCounter & "_MIP_Movie_CH1.avi", MOV_Frame, false, images=Images_CH1.SourceImage)
				WriteVideo(CreateDir & "/" & imagename & "_stack_" & _StackCounter & "_MIP_Movie_CH2.avi", MOV_Frame, false, images=Images_CH2.SourceImage)
			Else()
				set( filepath = substr( corename, 1, at("/", corename, -1)))
				WriteVideo(CreateDir & "/" & imagename & "_stack_" & _StackCounter & "_MIP_Movie_CH1.avi", MOV_Frame, false, images=Images_CH1.SourceImage)
			End()
		End()
	
	Else()
		// Cannot find enough suitable cell(s)
		Printf("Cannot find enough suitable cells - image discard! \n")	

		If(GenerateMovie)
			If(CameraNo == 2)	
				// Find the location and produce the movie
				set( filepath = substr( corename, 1, at("/", corename, -1)))
				WriteVideo(CreateDir & "/" & imagename & "_stack_" & _StackCounter & "_MIP_Movie_CH1.avi", MOV_Frame, false, images=Images_CH1.SourceImage)
				WriteVideo(CreateDir & "/" & imagename & "_stack_" & _StackCounter & "_MIP_Movie_CH2.avi", MOV_Frame, false, images=Images_CH2.SourceImage)
			Else()
				set( filepath = substr( corename, 1, at("/", corename, -1)))
				WriteVideo(CreateDir & "/" & imagename & "_stack_" & _StackCounter & "_MIP_Movie_CH1.avi", MOV_Frame, false, images=Images_CH1.SourceImage)
			End()
		End()
	
		Gamma(1.25, image=Cell_Value)
		WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_1_Cell_IMG.png", image=Image, imageformat="png")
		Gamma(1.25, image=Microtubule_Value)
		WriteImage(imagefile=CreateDir & "/" & imagename & "_Stack_" & _StackCounter & "_2_MT_IMG.png", image=Image, imageformat="png")

		Set(Experiment_Date = substr( Images_CH1.DateTime[0], 0, at("T", Images_CH1.DateTime[0], -1))) 
		Set(Imaging_Start_Time = substr( Images_CH1.DateTime[0], at("T", Images_CH1.DateTime[0], -1) + 1))
		Set(Imaging_End_Time = substr( Images_CH1.DateTime[Images_CH1.DateTime.size-1], at("T", Images_CH1.DateTime[Images_CH1.DateTime.size-1], -1) + 1))		

		printfopen(CreateDir & "/" & Output_File & ".csv", yes)
		printf(imagename & "#")
		Printf("R" & Images_CH1.Row[0] & " C"& Images_CH1.Column[0] & "#")
		Printf(Images_CH1.AreaName[0] & "#")
		Printf( _StackCounter & "#")
		Printf( Experiment_Date & "#")
		Printf( Imaging_Start_Time & "#")
		Printf( Imaging_End_Time & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(NAN & "#")
		Printf(Images_CH1.ImageResolutionX@um.mean & "#\n")
		printfopen() 


		// Finish exporting row for discarded stack
	End()

End()



	

